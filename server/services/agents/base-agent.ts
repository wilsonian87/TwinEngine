/**
 * Base Agent Class
 *
 * Phase 6C: Agentic Infrastructure for TwinEngine
 *
 * Provides the foundation for autonomous agents that:
 * - Monitor platform data and generate insights
 * - Propose actions through the approval workflow
 * - Integrate with external systems (Slack, Jira)
 * - Log all activities for audit/compliance
 */

import type {
  AgentDefinition,
  AgentRun,
  AgentAction,
  InsertAgentDefinition,
  InsertAgentRun,
  InsertAgentAction,
  AgentRunStatus,
  AgentActionStatus,
} from "@shared/schema";
import { debugLog, isDebug } from "../../utils/config";

// Agent types supported by the system
export const agentTypes = [
  "channel_health_monitor",
  "insight_synthesizer",
  "engagement_optimizer",
  "alert_manager",
  "regulatory_sync",
] as const;

export type AgentType = (typeof agentTypes)[number];

// Trigger configuration for when agents run
export interface AgentTriggerConfig {
  type: "scheduled" | "on_demand" | "event";
  schedule?: string; // Cron expression for scheduled triggers
  events?: string[]; // Event types that trigger the agent
}

// Input/output types for agent runs
export interface AgentInput {
  [key: string]: unknown;
}

export interface AgentOutput {
  success: boolean;
  summary: string;
  insights?: AgentInsight[];
  alerts?: AgentAlert[];
  proposedActions?: ProposedAgentAction[];
  metrics?: Record<string, number>;
  error?: string;
}

// Insights generated by agents
export interface AgentInsight {
  type: string;
  title: string;
  description: string;
  severity: "info" | "warning" | "critical";
  affectedEntities?: {
    type: string;
    ids: string[];
    count: number;
  };
  metrics?: Record<string, number | string>;
  recommendation?: string;
}

// Alerts that agents can generate
export interface AgentAlert {
  severity: "info" | "warning" | "critical";
  title: string;
  message: string;
  channel?: string;
  affectedEntities?: {
    type: string;
    ids: string[];
    count: number;
  };
  suggestedActions?: {
    type: string;
    label: string;
    payload: Record<string, unknown>;
  }[];
}

// Actions that agents propose
export interface ProposedAgentAction {
  actionType: string;
  actionName: string;
  description: string;
  reasoning: string;
  confidence: number;
  riskLevel: "low" | "medium" | "high";
  impactScope: "individual" | "segment" | "portfolio";
  affectedEntityCount: number;
  payload: Record<string, unknown>;
  requiresApproval: boolean;
}

// Execution context provided to agents
export interface AgentContext {
  agentId: string;
  runId: string;
  triggeredBy: string;
  triggerType: "scheduled" | "on_demand" | "event";
  triggerEvent?: string;
  startTime: Date;
}

// Logging interface for agent activities
export interface AgentLogger {
  info(message: string, data?: unknown): void;
  warn(message: string, data?: unknown): void;
  error(message: string, data?: unknown): void;
  debug(message: string, data?: unknown): void;
}

/**
 * Base Agent Class
 *
 * All agents extend this class to implement their specific logic.
 * The base class handles:
 * - Run lifecycle (start, execute, complete)
 * - Logging and error handling
 * - Action proposal through approval workflow
 * - Integration with storage layer
 */
export abstract class BaseAgent<TInput extends AgentInput = AgentInput> {
  abstract readonly type: AgentType;
  abstract readonly name: string;
  abstract readonly description: string;
  abstract readonly version: string;

  protected context: AgentContext | null = null;
  protected logger: AgentLogger;

  constructor() {
    this.logger = this.createLogger();
  }

  /**
   * Execute the agent's main logic
   * Subclasses must implement this method
   */
  abstract execute(input: TInput, context: AgentContext): Promise<AgentOutput>;

  /**
   * Validate input before execution
   * Subclasses can override for custom validation
   */
  validate(input: TInput): { valid: boolean; errors?: string[] } {
    return { valid: true };
  }

  /**
   * Get the default input values for this agent
   */
  getDefaultInput(): Partial<TInput> {
    return {};
  }

  /**
   * Get the input schema for this agent (for documentation/validation)
   */
  getInputSchema(): Record<string, { type: string; required: boolean; description: string }> {
    return {};
  }

  /**
   * Run the agent with the given input
   * This is the main entry point for executing the agent
   */
  async run(
    input: TInput,
    triggeredBy: string,
    triggerType: "scheduled" | "on_demand" | "event" = "on_demand",
    triggerEvent?: string
  ): Promise<{
    runId: string;
    output: AgentOutput;
    duration: number;
    status: AgentRunStatus;
  }> {
    const runId = `run-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;
    const startTime = new Date();

    const context: AgentContext = {
      agentId: `agent-${this.type}`,
      runId,
      triggeredBy,
      triggerType,
      triggerEvent,
      startTime,
    };

    this.context = context;
    this.logger.info(`Starting agent run`, { runId, input, triggerType });

    let output: AgentOutput;
    let status: AgentRunStatus = "completed";

    try {
      // Validate input
      const validation = this.validate(input);
      if (!validation.valid) {
        throw new Error(`Invalid input: ${validation.errors?.join(", ")}`);
      }

      // Execute agent logic
      output = await this.execute(input, context);

      if (!output.success) {
        status = "failed";
      }
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      this.logger.error(`Agent run failed`, { error: errorMessage });

      output = {
        success: false,
        summary: `Agent execution failed: ${errorMessage}`,
        error: errorMessage,
      };
      status = "failed";
    }

    const endTime = new Date();
    const duration = endTime.getTime() - startTime.getTime();

    this.logger.info(`Agent run completed`, {
      runId,
      status,
      duration,
      summary: output.summary,
    });

    this.context = null;

    return {
      runId,
      output,
      duration,
      status,
    };
  }

  /**
   * Propose an action for approval
   * Returns the proposed action record
   */
  protected proposeAction(action: ProposedAgentAction): InsertAgentAction {
    if (!this.context) {
      throw new Error("Cannot propose action outside of agent run context");
    }

    return {
      agentId: this.context.agentId,
      agentRunId: this.context.runId,
      agentType: this.type,
      actionType: action.actionType,
      actionName: action.actionName,
      proposedAction: {
        payload: action.payload,
        destination: {
          type: action.actionType,
          integrationId: "default",
        },
      },
      reasoning: action.reasoning,
      confidence: action.confidence,
      riskLevel: action.riskLevel,
      impactScope: action.impactScope,
      affectedEntityCount: action.affectedEntityCount,
      status: action.requiresApproval ? "pending" : "auto_approved",
    };
  }

  /**
   * Create a logger instance for this agent
   */
  private createLogger(): AgentLogger {
    return {
      info: (message: string, data?: unknown) => {
        debugLog(this.type, message, data);
      },
      warn: (message: string, data?: unknown) => {
        // Warnings always shown
        console.warn(`[${this.type}] ${message}`, data !== undefined ? data : "");
      },
      error: (message: string, data?: unknown) => {
        // Errors always shown
        console.error(`[${this.type}] ${message}`, data !== undefined ? data : "");
      },
      debug: (message: string, data?: unknown) => {
        if (isDebug) {
          debugLog(this.type, `[DEBUG] ${message}`, data);
        }
      },
    };
  }

  /**
   * Get agent definition for storage
   */
  getDefinition(config: {
    scheduled?: { enabled: boolean; cron?: string; timezone?: string };
    onDemand?: boolean;
    eventDriven?: { enabled: boolean; events: string[] };
  }): InsertAgentDefinition {
    return {
      type: this.type,
      name: this.name,
      description: this.description,
      version: this.version,
      triggers: config,
      inputSchema: this.getInputSchema(),
      defaultInputs: this.getDefaultInput(),
      status: "active",
    };
  }
}

/**
 * Create an agent run record for storage
 */
export function createAgentRunRecord(
  agent: BaseAgent,
  context: AgentContext,
  output: AgentOutput,
  status: AgentRunStatus,
  duration: number
): InsertAgentRun {
  return {
    agentId: context.agentId,
    agentType: agent.type,
    agentVersion: agent.version,
    triggerType: context.triggerType,
    triggeredBy: context.triggeredBy,
    triggerEvent: context.triggerEvent,
    inputs: {},
    outputs: {
      alerts: output.alerts?.map((a, idx) => ({
        id: `alert-${context.runId}-${idx}`,
        severity: a.severity,
        title: a.title,
        message: a.message,
      })),
      recommendations: output.insights?.map((i, idx) => ({
        id: `insight-${context.runId}-${idx}`,
        type: i.type,
        description: i.description,
        confidence: 0.8,
      })),
      metrics: output.metrics,
      raw: { summary: output.summary },
    },
    status,
    startedAt: context.startTime,
    completedAt: new Date(),
    executionTimeMs: duration,
    actionsProposed: output.proposedActions?.length || 0,
    errorMessage: output.error,
  };
}

/**
 * Agent registry for managing agent instances
 */
export class AgentRegistry {
  private static instance: AgentRegistry;
  private agents: Map<AgentType, BaseAgent> = new Map();

  private constructor() {}

  static getInstance(): AgentRegistry {
    if (!AgentRegistry.instance) {
      AgentRegistry.instance = new AgentRegistry();
    }
    return AgentRegistry.instance;
  }

  register(agent: BaseAgent): void {
    this.agents.set(agent.type, agent);
    debugLog("AgentRegistry", `Registered agent: ${agent.type} v${agent.version}`);
  }

  get(type: AgentType): BaseAgent | undefined {
    return this.agents.get(type);
  }

  getAll(): BaseAgent[] {
    return Array.from(this.agents.values());
  }

  has(type: AgentType): boolean {
    return this.agents.has(type);
  }
}
