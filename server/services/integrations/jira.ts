/**
 * Jira Integration Service
 *
 * Provides Jira issue management capabilities for TwinEngine.
 * Uses Jira REST API v3 for cloud instances.
 *
 * Features:
 * - Create issues from NBA recommendations
 * - Create issues from simulation results
 * - Get issue details and status
 * - Update issue status and fields
 * - Ticket templates for different use cases
 */

import type {
  IntegrationConfig,
  ActionExport,
  InsertActionExport,
} from "@shared/schema";
import { storage } from "../../storage";

// Jira API response types
interface JiraApiResponse {
  id?: string;
  key?: string;
  self?: string;
  errorMessages?: string[];
  errors?: Record<string, string>;
}

interface JiraIssue {
  id: string;
  key: string;
  self: string;
  fields: {
    summary: string;
    description?: string;
    status: {
      name: string;
      statusCategory: {
        key: string;
        name: string;
      };
    };
    issuetype: {
      name: string;
    };
    priority?: {
      name: string;
    };
    assignee?: {
      displayName: string;
      emailAddress: string;
    };
    created: string;
    updated: string;
    labels?: string[];
    [key: string]: unknown;
  };
}

// Jira issue creation request
export interface JiraCreateIssueRequest {
  integrationId: string;
  projectKey: string;
  issueType: string;
  summary: string;
  description?: string;
  priority?: string;
  labels?: string[];
  customFields?: Record<string, unknown>;
  sourceType: string;
  sourceId: string;
}

// Jira issue update request
export interface JiraUpdateIssueRequest {
  integrationId: string;
  issueKey: string;
  fields: {
    summary?: string;
    description?: string;
    priority?: string;
    labels?: string[];
    status?: string;
    [key: string]: unknown;
  };
}

// Jira create result
export interface JiraCreateResult {
  success: boolean;
  issueKey?: string;
  issueId?: string;
  issueUrl?: string;
  error?: string;
  actionExportId?: string;
}

// Jira get result
export interface JiraGetResult {
  success: boolean;
  issue?: JiraIssue;
  error?: string;
}

// Jira update result
export interface JiraUpdateResult {
  success: boolean;
  issueKey?: string;
  error?: string;
}

// Ticket template types
export type TicketTemplateType = "nba_action" | "simulation_result" | "channel_alert" | "custom";

export interface TicketTemplate {
  type: TicketTemplateType;
  name: string;
  projectKey: string;
  issueType: string;
  summaryTemplate: string;
  descriptionTemplate: string;
  defaultPriority: string;
  defaultLabels: string[];
}

// Default ticket templates
export const defaultTicketTemplates: Record<TicketTemplateType, Omit<TicketTemplate, "projectKey">> = {
  nba_action: {
    type: "nba_action",
    name: "NBA Action Item",
    issueType: "Task",
    summaryTemplate: "[NBA] {{actionType}} - {{hcpName}} via {{channel}}",
    descriptionTemplate: `h2. Next Best Action Recommendation

*HCP:* {{hcpName}}
*Recommended Channel:* {{channel}}
*Action Type:* {{actionType}}
*Confidence:* {{confidence}}%
*Urgency:* {{urgency}}

h3. Reasoning
{{reasoning}}

h3. Suggested Timing
{{timing}}

h3. Channel Metrics
* Channel Score: {{channelScore}}
* Response Rate: {{responseRate}}%
* Last Contact: {{lastContact}}

---
_Generated by TwinEngine on {{date}}_`,
    defaultPriority: "Medium",
    defaultLabels: ["twinengine", "nba"],
  },
  simulation_result: {
    type: "simulation_result",
    name: "Simulation Follow-up",
    issueType: "Task",
    summaryTemplate: "[Simulation] {{scenarioName}} - Review Results",
    descriptionTemplate: `h2. Simulation Results Review

*Scenario:* {{scenarioName}}
*Run Date:* {{runDate}}

h3. Predicted Outcomes
* Engagement Rate: {{engagementRate}}%
* Response Rate: {{responseRate}}%
* Rx Lift: {{rxLift}}%
* Reach: {{reach}} HCPs

h3. Efficiency
* Cost per Engagement: {{costPerEngagement}}
* Efficiency Score: {{efficiencyScore}}

h3. vs. Baseline
* Engagement: {{baselineEngagement}}
* Response: {{baselineResponse}}
* Rx Volume: {{baselineRx}}

h3. Action Items
# Review channel performance breakdown
# Validate assumptions with field team
# Consider optimization opportunities

---
_Generated by TwinEngine on {{date}}_`,
    defaultPriority: "Low",
    defaultLabels: ["twinengine", "simulation"],
  },
  channel_alert: {
    type: "channel_alert",
    name: "Channel Health Alert",
    issueType: "Bug",
    summaryTemplate: "[Alert] Channel Health Issue - {{channel}} for {{hcpCount}} HCPs",
    descriptionTemplate: `h2. Channel Health Alert

*Alert Type:* {{alertType}}
*Channel:* {{channel}}
*Affected HCPs:* {{hcpCount}}
*Severity:* {{severity}}

h3. Issue Details
{{description}}

h3. Recommended Actions
{{recommendations}}

---
_Generated by TwinEngine on {{date}}_`,
    defaultPriority: "High",
    defaultLabels: ["twinengine", "alert", "channel-health"],
  },
  custom: {
    type: "custom",
    name: "Custom Ticket",
    issueType: "Task",
    summaryTemplate: "{{summary}}",
    descriptionTemplate: "{{description}}",
    defaultPriority: "Medium",
    defaultLabels: ["twinengine"],
  },
};

/**
 * Jira Integration Service
 *
 * Handles all Jira-related operations for TwinEngine.
 */
export class JiraIntegration {
  private config: IntegrationConfig;
  private baseUrl?: string;
  private email?: string;
  private apiToken?: string;

  constructor(config: IntegrationConfig) {
    this.config = config;

    // Extract credentials
    if (config.credentials && typeof config.credentials === "object") {
      const creds = config.credentials as {
        type: string;
        baseUrl?: string;
        email?: string;
        apiToken?: string;
      };
      if (creds.type === "jira") {
        this.baseUrl = creds.baseUrl;
        this.email = creds.email;
        this.apiToken = creds.apiToken;
      }
    }
  }

  /**
   * Create a new Jira issue
   */
  async createIssue(request: JiraCreateIssueRequest): Promise<JiraCreateResult> {
    // Create action export record
    const actionExport = await this.createExportRecord(request, "jira_issue");

    try {
      // Check if we have credentials
      if (!this.baseUrl || !this.email || !this.apiToken) {
        // Development mode - simulate success
        console.log("[Jira] No credentials - simulating issue creation:", {
          project: request.projectKey,
          summary: request.summary.substring(0, 50) + "...",
        });

        const mockKey = `${request.projectKey}-${Math.floor(Math.random() * 1000)}`;
        await this.updateExportSuccess(actionExport.id, mockKey, `${this.baseUrl || "https://example.atlassian.net"}/browse/${mockKey}`);

        return {
          success: true,
          issueKey: mockKey,
          issueId: `dev-${Date.now()}`,
          issueUrl: `https://example.atlassian.net/browse/${mockKey}`,
          actionExportId: actionExport.id,
        };
      }

      // Build the issue payload
      const payload = this.buildCreatePayload(request);

      // Create via Jira API
      const result = await this.callJiraApi("POST", "/rest/api/3/issue", payload);

      if (result.key) {
        const issueUrl = `${this.baseUrl}/browse/${result.key}`;
        await this.updateExportSuccess(actionExport.id, result.key, issueUrl);

        return {
          success: true,
          issueKey: result.key,
          issueId: result.id,
          issueUrl,
          actionExportId: actionExport.id,
        };
      } else {
        const error = result.errorMessages?.join(", ") ||
          Object.values(result.errors || {}).join(", ") ||
          "Unknown Jira error";
        await this.updateExportFailure(actionExport.id, error);

        return {
          success: false,
          error,
          actionExportId: actionExport.id,
        };
      }
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : "Unknown error";
      await this.updateExportFailure(actionExport.id, errorMessage);

      return {
        success: false,
        error: errorMessage,
        actionExportId: actionExport.id,
      };
    }
  }

  /**
   * Get a Jira issue by key
   */
  async getIssue(issueKey: string): Promise<JiraGetResult> {
    try {
      if (!this.baseUrl || !this.email || !this.apiToken) {
        // Dev mode - return mock issue
        return {
          success: true,
          issue: {
            id: "dev-12345",
            key: issueKey,
            self: `https://example.atlassian.net/rest/api/3/issue/${issueKey}`,
            fields: {
              summary: `[Dev Mode] Mock issue ${issueKey}`,
              description: "This is a mock issue for development",
              status: {
                name: "To Do",
                statusCategory: { key: "new", name: "To Do" },
              },
              issuetype: { name: "Task" },
              priority: { name: "Medium" },
              created: new Date().toISOString(),
              updated: new Date().toISOString(),
              labels: ["twinengine", "dev-mode"],
            },
          },
        };
      }

      const result = await this.callJiraApi("GET", `/rest/api/3/issue/${issueKey}`);

      if (result.key) {
        return {
          success: true,
          issue: result as unknown as JiraIssue,
        };
      } else {
        return {
          success: false,
          error: result.errorMessages?.join(", ") || "Issue not found",
        };
      }
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : "Unknown error",
      };
    }
  }

  /**
   * Update a Jira issue
   */
  async updateIssue(request: JiraUpdateIssueRequest): Promise<JiraUpdateResult> {
    try {
      if (!this.baseUrl || !this.email || !this.apiToken) {
        // Dev mode - simulate success
        console.log("[Jira] No credentials - simulating issue update:", {
          issueKey: request.issueKey,
          fields: Object.keys(request.fields),
        });

        return {
          success: true,
          issueKey: request.issueKey,
        };
      }

      const payload: Record<string, unknown> = { fields: {} };

      // Map fields to Jira format
      if (request.fields.summary) {
        (payload.fields as Record<string, unknown>).summary = request.fields.summary;
      }
      if (request.fields.description) {
        (payload.fields as Record<string, unknown>).description = {
          type: "doc",
          version: 1,
          content: [
            {
              type: "paragraph",
              content: [{ type: "text", text: request.fields.description }],
            },
          ],
        };
      }
      if (request.fields.priority) {
        (payload.fields as Record<string, unknown>).priority = { name: request.fields.priority };
      }
      if (request.fields.labels) {
        (payload.fields as Record<string, unknown>).labels = request.fields.labels;
      }

      await this.callJiraApi("PUT", `/rest/api/3/issue/${request.issueKey}`, payload);

      // Handle status transition separately if provided
      if (request.fields.status) {
        await this.transitionIssue(request.issueKey, request.fields.status);
      }

      return {
        success: true,
        issueKey: request.issueKey,
      };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : "Unknown error",
      };
    }
  }

  /**
   * Transition an issue to a new status
   */
  async transitionIssue(issueKey: string, targetStatus: string): Promise<boolean> {
    try {
      // Get available transitions
      const transitions = await this.callJiraApi("GET", `/rest/api/3/issue/${issueKey}/transitions`);

      const transition = (transitions.transitions as Array<{ id: string; name: string }>)?.find(
        (t) => t.name.toLowerCase() === targetStatus.toLowerCase()
      );

      if (!transition) {
        console.log(`[Jira] Transition to "${targetStatus}" not available for ${issueKey}`);
        return false;
      }

      await this.callJiraApi("POST", `/rest/api/3/issue/${issueKey}/transitions`, {
        transition: { id: transition.id },
      });

      return true;
    } catch (error) {
      console.error("[Jira] Transition failed:", error);
      return false;
    }
  }

  /**
   * Check if Jira connection is healthy
   */
  async healthCheck(): Promise<{ healthy: boolean; error?: string; serverInfo?: unknown }> {
    if (!this.baseUrl || !this.email || !this.apiToken) {
      return {
        healthy: false,
        error: "Jira credentials not configured",
      };
    }

    try {
      const result = await this.callJiraApi("GET", "/rest/api/3/serverInfo");

      if (result.baseUrl) {
        await storage.updateIntegrationStatus(this.config.id, "active");
        return {
          healthy: true,
          serverInfo: result,
        };
      } else {
        await storage.updateIntegrationStatus(this.config.id, "error", "Invalid server response");
        return {
          healthy: false,
          error: "Invalid server response",
        };
      }
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : "Unknown error";
      await storage.updateIntegrationStatus(this.config.id, "error", errorMessage);
      return {
        healthy: false,
        error: errorMessage,
      };
    }
  }

  /**
   * Get available projects
   */
  async getProjects(): Promise<Array<{ key: string; name: string }>> {
    if (!this.baseUrl || !this.email || !this.apiToken) {
      // Dev mode - return mock projects
      return [
        { key: "TWIN", name: "TwinEngine" },
        { key: "HCP", name: "HCP Engagement" },
        { key: "MKT", name: "Marketing" },
      ];
    }

    try {
      const result = await this.callJiraApi("GET", "/rest/api/3/project/search?maxResults=50");
      return (result.values as Array<{ key: string; name: string }>) || [];
    } catch {
      return [];
    }
  }

  /**
   * Get available issue types for a project
   */
  async getIssueTypes(projectKey: string): Promise<Array<{ id: string; name: string }>> {
    if (!this.baseUrl || !this.email || !this.apiToken) {
      // Dev mode - return common issue types
      return [
        { id: "1", name: "Task" },
        { id: "2", name: "Bug" },
        { id: "3", name: "Story" },
        { id: "4", name: "Epic" },
      ];
    }

    try {
      const result = await this.callJiraApi("GET", `/rest/api/3/project/${projectKey}`);
      return (result.issueTypes as Array<{ id: string; name: string }>) || [];
    } catch {
      return [];
    }
  }

  /**
   * Format an NBA as a Jira issue request
   */
  formatNBAAsIssue(
    nba: {
      hcpId: string;
      hcpName: string;
      recommendedChannel: string;
      actionType: string;
      urgency: string;
      confidence: number;
      reasoning: string;
      suggestedTiming: string;
      metrics: {
        channelScore: number;
        responseRate: number;
        lastContactDays?: number;
      };
    },
    projectKey: string,
    template: TicketTemplate = { ...defaultTicketTemplates.nba_action, projectKey }
  ): JiraCreateIssueRequest {
    // Replace template variables
    const variables: Record<string, string> = {
      hcpName: nba.hcpName,
      hcpId: nba.hcpId,
      channel: nba.recommendedChannel,
      actionType: nba.actionType,
      urgency: nba.urgency,
      confidence: nba.confidence.toString(),
      reasoning: nba.reasoning,
      timing: nba.suggestedTiming,
      channelScore: nba.metrics.channelScore.toString(),
      responseRate: nba.metrics.responseRate.toString(),
      lastContact: nba.metrics.lastContactDays ? `${nba.metrics.lastContactDays} days ago` : "N/A",
      date: new Date().toLocaleString(),
    };

    const summary = this.replaceTemplateVariables(template.summaryTemplate, variables);
    const description = this.replaceTemplateVariables(template.descriptionTemplate, variables);

    // Map urgency to priority
    const priorityMap: Record<string, string> = {
      high: "High",
      medium: "Medium",
      low: "Low",
    };

    return {
      integrationId: this.config.id,
      projectKey,
      issueType: template.issueType,
      summary,
      description,
      priority: priorityMap[nba.urgency] || template.defaultPriority,
      labels: [...template.defaultLabels, `hcp-${nba.hcpId}`],
      sourceType: "nba",
      sourceId: nba.hcpId,
    };
  }

  /**
   * Format a simulation result as a Jira issue request
   */
  formatSimulationAsIssue(
    simulation: {
      id: string;
      scenarioName: string;
      predictedEngagementRate: number;
      predictedResponseRate: number;
      predictedRxLift: number;
      predictedReach: number;
      costPerEngagement?: number;
      efficiencyScore: number;
      vsBaseline: {
        engagement: string;
        response: string;
        rxVolume: string;
      };
      runAt: string;
    },
    projectKey: string,
    template: TicketTemplate = { ...defaultTicketTemplates.simulation_result, projectKey }
  ): JiraCreateIssueRequest {
    const variables: Record<string, string> = {
      scenarioName: simulation.scenarioName,
      runDate: new Date(simulation.runAt).toLocaleString(),
      engagementRate: simulation.predictedEngagementRate.toFixed(1),
      responseRate: simulation.predictedResponseRate.toFixed(1),
      rxLift: simulation.predictedRxLift.toFixed(1),
      reach: simulation.predictedReach.toString(),
      costPerEngagement: simulation.costPerEngagement ? `$${simulation.costPerEngagement.toFixed(2)}` : "N/A",
      efficiencyScore: simulation.efficiencyScore.toFixed(1),
      baselineEngagement: simulation.vsBaseline.engagement,
      baselineResponse: simulation.vsBaseline.response,
      baselineRx: simulation.vsBaseline.rxVolume,
      date: new Date().toLocaleString(),
    };

    const summary = this.replaceTemplateVariables(template.summaryTemplate, variables);
    const description = this.replaceTemplateVariables(template.descriptionTemplate, variables);

    return {
      integrationId: this.config.id,
      projectKey,
      issueType: template.issueType,
      summary,
      description,
      priority: template.defaultPriority,
      labels: [...template.defaultLabels, `simulation-${simulation.id}`],
      sourceType: "simulation",
      sourceId: simulation.id,
    };
  }

  /**
   * Replace template variables with values
   */
  private replaceTemplateVariables(template: string, variables: Record<string, string>): string {
    let result = template;
    for (const [key, value] of Object.entries(variables)) {
      result = result.replace(new RegExp(`\\{\\{${key}\\}\\}`, "g"), value);
    }
    return result;
  }

  /**
   * Build the Jira API payload for issue creation
   */
  private buildCreatePayload(request: JiraCreateIssueRequest): Record<string, unknown> {
    const payload: Record<string, unknown> = {
      fields: {
        project: { key: request.projectKey },
        issuetype: { name: request.issueType },
        summary: request.summary,
      },
    };

    const fields = payload.fields as Record<string, unknown>;

    // Add description in Atlassian Document Format (ADF)
    if (request.description) {
      fields.description = {
        type: "doc",
        version: 1,
        content: this.convertToADF(request.description),
      };
    }

    if (request.priority) {
      fields.priority = { name: request.priority };
    }

    if (request.labels && request.labels.length > 0) {
      fields.labels = request.labels;
    }

    // Add any custom fields
    if (request.customFields) {
      Object.assign(fields, request.customFields);
    }

    return payload;
  }

  /**
   * Convert wiki-style markup to Atlassian Document Format (ADF)
   */
  private convertToADF(text: string): unknown[] {
    const content: unknown[] = [];
    const lines = text.split("\n");
    let currentParagraph: unknown[] = [];

    for (const line of lines) {
      if (line.startsWith("h2. ")) {
        // Flush current paragraph
        if (currentParagraph.length > 0) {
          content.push({ type: "paragraph", content: currentParagraph });
          currentParagraph = [];
        }
        content.push({
          type: "heading",
          attrs: { level: 2 },
          content: [{ type: "text", text: line.substring(4) }],
        });
      } else if (line.startsWith("h3. ")) {
        if (currentParagraph.length > 0) {
          content.push({ type: "paragraph", content: currentParagraph });
          currentParagraph = [];
        }
        content.push({
          type: "heading",
          attrs: { level: 3 },
          content: [{ type: "text", text: line.substring(4) }],
        });
      } else if (line.startsWith("* ")) {
        if (currentParagraph.length > 0) {
          content.push({ type: "paragraph", content: currentParagraph });
          currentParagraph = [];
        }
        content.push({
          type: "bulletList",
          content: [
            {
              type: "listItem",
              content: [
                {
                  type: "paragraph",
                  content: [{ type: "text", text: line.substring(2) }],
                },
              ],
            },
          ],
        });
      } else if (line.startsWith("# ")) {
        if (currentParagraph.length > 0) {
          content.push({ type: "paragraph", content: currentParagraph });
          currentParagraph = [];
        }
        content.push({
          type: "orderedList",
          content: [
            {
              type: "listItem",
              content: [
                {
                  type: "paragraph",
                  content: [{ type: "text", text: line.substring(2) }],
                },
              ],
            },
          ],
        });
      } else if (line === "---") {
        if (currentParagraph.length > 0) {
          content.push({ type: "paragraph", content: currentParagraph });
          currentParagraph = [];
        }
        content.push({ type: "rule" });
      } else if (line.trim() === "") {
        if (currentParagraph.length > 0) {
          content.push({ type: "paragraph", content: currentParagraph });
          currentParagraph = [];
        }
      } else {
        // Handle inline formatting
        const formatted = this.formatInlineText(line);
        currentParagraph.push(...formatted);
        currentParagraph.push({ type: "hardBreak" });
      }
    }

    // Flush remaining paragraph
    if (currentParagraph.length > 0) {
      content.push({ type: "paragraph", content: currentParagraph });
    }

    return content;
  }

  /**
   * Format inline text with bold/italic markers
   */
  private formatInlineText(text: string): unknown[] {
    const result: unknown[] = [];
    // Simple bold detection: *text*
    const parts = text.split(/(\*[^*]+\*)/);

    for (const part of parts) {
      if (part.startsWith("*") && part.endsWith("*")) {
        result.push({
          type: "text",
          text: part.slice(1, -1),
          marks: [{ type: "strong" }],
        });
      } else if (part.startsWith("_") && part.endsWith("_")) {
        result.push({
          type: "text",
          text: part.slice(1, -1),
          marks: [{ type: "em" }],
        });
      } else if (part) {
        result.push({ type: "text", text: part });
      }
    }

    return result;
  }

  /**
   * Make a call to the Jira REST API
   */
  private async callJiraApi(
    method: string,
    endpoint: string,
    body?: Record<string, unknown>
  ): Promise<JiraApiResponse & Record<string, unknown>> {
    if (!this.baseUrl || !this.email || !this.apiToken) {
      throw new Error("Jira credentials not configured");
    }

    const url = `${this.baseUrl}${endpoint}`;
    const auth = Buffer.from(`${this.email}:${this.apiToken}`).toString("base64");

    const options: RequestInit = {
      method,
      headers: {
        "Authorization": `Basic ${auth}`,
        "Content-Type": "application/json",
        "Accept": "application/json",
      },
    };

    if (body && (method === "POST" || method === "PUT")) {
      options.body = JSON.stringify(body);
    }

    const response = await fetch(url, options);

    // Handle no content responses
    if (response.status === 204) {
      return {};
    }

    if (!response.ok && response.status !== 400) {
      throw new Error(`Jira API error: ${response.status} ${response.statusText}`);
    }

    return await response.json();
  }

  /**
   * Create an action export record
   */
  private async createExportRecord(
    request: JiraCreateIssueRequest,
    destinationType: string
  ): Promise<ActionExport> {
    const exportData: InsertActionExport = {
      sourceType: request.sourceType,
      sourceId: request.sourceId,
      integrationId: this.config.id,
      destinationType,
      payload: {
        projectKey: request.projectKey,
        issueType: request.issueType,
        summary: request.summary,
      },
      status: "pending",
    };

    return storage.createActionExport(exportData);
  }

  /**
   * Update export record on success
   */
  private async updateExportSuccess(
    exportId: string,
    issueKey: string,
    issueUrl: string
  ): Promise<void> {
    await storage.updateActionExportStatus(exportId, "success", issueKey, issueUrl);
  }

  /**
   * Update export record on failure
   */
  private async updateExportFailure(exportId: string, error: string): Promise<void> {
    await storage.updateActionExportStatus(exportId, "failed", undefined, undefined, error);
  }
}

/**
 * Factory function to create a Jira integration from config
 */
export function createJiraIntegration(config: IntegrationConfig): JiraIntegration {
  if (config.type !== "jira") {
    throw new Error(`Invalid integration type: ${config.type}. Expected 'jira'.`);
  }
  return new JiraIntegration(config);
}

/**
 * Get or create a Jira integration instance
 */
export async function getJiraIntegration(): Promise<JiraIntegration | null> {
  const config = await storage.getIntegrationByType("jira");
  if (!config) {
    return null;
  }
  return new JiraIntegration(config);
}

/**
 * Check if Jira integration is configured
 */
export async function isJiraConfigured(): Promise<boolean> {
  const config = await storage.getIntegrationByType("jira");
  return config !== undefined && config.status === "active";
}
